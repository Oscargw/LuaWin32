{
    "sourceFile": "lualib/source/luac.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1653549619150,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1653549642839,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,8 +194,9 @@\n  }\n  return 0;\n }\n \n+// aosika，屏蔽main函数\n // int main(int argc, char* argv[])\n // {\n //  lua_State* L;\n //  int i=doargs(argc,argv);\n"
                }
            ],
            "date": 1653549619150,
            "name": "Commit-0",
            "content": "/*\n** $Id: luac.c $\n** Lua compiler (saves bytecodes to files; also lists bytecodes)\n** See Copyright Notice in lua.h\n*/\n\n#define luac_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n#include <ctype.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n#include \"lauxlib.h\"\n\n#include \"ldebug.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lopnames.h\"\n#include \"lstate.h\"\n#include \"lundump.h\"\n\nstatic void PrintFunction(const Proto* f, int full);\n#define luaU_print\tPrintFunction\n\n#define PROGNAME\t\"luac\"\t\t/* default program name */\n#define OUTPUT\t\tPROGNAME \".out\"\t/* default output file */\n\nstatic int listing=0;\t\t\t/* list bytecodes? */\nstatic int dumping=1;\t\t\t/* dump bytecodes? */\nstatic int stripping=0;\t\t\t/* strip debug information? */\nstatic char Output[]={ OUTPUT };\t/* default output file name */\nstatic const char* output=Output;\t/* actual output file name */\nstatic const char* progname=PROGNAME;\t/* actual program name */\nstatic TString **tmname;\n\nstatic void fatal(const char* message)\n{\n fprintf(stderr,\"%s: %s\\n\",progname,message);\n exit(EXIT_FAILURE);\n}\n\nstatic void cannot(const char* what)\n{\n fprintf(stderr,\"%s: cannot %s %s: %s\\n\",progname,what,output,strerror(errno));\n exit(EXIT_FAILURE);\n}\n\nstatic void usage(const char* message)\n{\n if (*message=='-')\n  fprintf(stderr,\"%s: unrecognized option '%s'\\n\",progname,message);\n else\n  fprintf(stderr,\"%s: %s\\n\",progname,message);\n fprintf(stderr,\n  \"usage: %s [options] [filenames]\\n\"\n  \"Available options are:\\n\"\n  \"  -l       list (use -l -l for full listing)\\n\"\n  \"  -o name  output to file 'name' (default is \\\"%s\\\")\\n\"\n  \"  -p       parse only\\n\"\n  \"  -s       strip debug information\\n\"\n  \"  -v       show version information\\n\"\n  \"  --       stop handling options\\n\"\n  \"  -        stop handling options and process stdin\\n\"\n  ,progname,Output);\n exit(EXIT_FAILURE);\n}\n\n#define IS(s)\t(strcmp(argv[i],s)==0)\n\nstatic int doargs(int argc, char* argv[])\n{\n int i;\n int version=0;\n if (argv[0]!=NULL && *argv[0]!=0) progname=argv[0];\n for (i=1; i<argc; i++)\n {\n  if (*argv[i]!='-')\t\t\t/* end of options; keep it */\n   break;\n  else if (IS(\"--\"))\t\t\t/* end of options; skip it */\n  {\n   ++i;\n   if (version) ++version;\n   break;\n  }\n  else if (IS(\"-\"))\t\t\t/* end of options; use stdin */\n   break;\n  else if (IS(\"-l\"))\t\t\t/* list */\n   ++listing;\n  else if (IS(\"-o\"))\t\t\t/* output file */\n  {\n   output=argv[++i];\n   if (output==NULL || *output==0 || (*output=='-' && output[1]!=0))\n    usage(\"'-o' needs argument\");\n   if (IS(\"-\")) output=NULL;\n  }\n  else if (IS(\"-p\"))\t\t\t/* parse only */\n   dumping=0;\n  else if (IS(\"-s\"))\t\t\t/* strip debug information */\n   stripping=1;\n  else if (IS(\"-v\"))\t\t\t/* show version */\n   ++version;\n  else\t\t\t\t\t/* unknown option */\n   usage(argv[i]);\n }\n if (i==argc && (listing || !dumping))\n {\n  dumping=0;\n  argv[--i]=Output;\n }\n if (version)\n {\n  printf(\"%s\\n\",LUA_COPYRIGHT);\n  if (version==argc-1) exit(EXIT_SUCCESS);\n }\n return i;\n}\n\n#define FUNCTION \"(function()end)();\"\n\nstatic const char* reader(lua_State* L, void* ud, size_t* size)\n{\n UNUSED(L);\n if ((*(int*)ud)--)\n {\n  *size=sizeof(FUNCTION)-1;\n  return FUNCTION;\n }\n else\n {\n  *size=0;\n  return NULL;\n }\n}\n\n#define toproto(L,i) getproto(s2v(L->top+(i)))\n\nstatic const Proto* combine(lua_State* L, int n)\n{\n if (n==1)\n  return toproto(L,-1);\n else\n {\n  Proto* f;\n  int i=n;\n  if (lua_load(L,reader,&i,\"=(\" PROGNAME \")\",NULL)!=LUA_OK) fatal(lua_tostring(L,-1));\n  f=toproto(L,-1);\n  for (i=0; i<n; i++)\n  {\n   f->p[i]=toproto(L,i-n-1);\n   if (f->p[i]->sizeupvalues>0) f->p[i]->upvalues[0].instack=0;\n  }\n  luaM_freearray(L,f->lineinfo,f->sizelineinfo);\n  f->sizelineinfo=0;\n  return f;\n }\n}\n\nstatic int writer(lua_State* L, const void* p, size_t size, void* u)\n{\n UNUSED(L);\n return (fwrite(p,size,1,(FILE*)u)!=1) && (size!=0);\n}\n\nstatic int pmain(lua_State* L)\n{\n int argc=(int)lua_tointeger(L,1);\n char** argv=(char**)lua_touserdata(L,2);\n const Proto* f;\n int i;\n tmname=G(L)->tmname;\n if (!lua_checkstack(L,argc)) fatal(\"too many input files\");\n for (i=0; i<argc; i++)\n {\n  const char* filename=IS(\"-\") ? NULL : argv[i];\n  if (luaL_loadfile(L,filename)!=LUA_OK) fatal(lua_tostring(L,-1));\n }\n f=combine(L,argc);\n if (listing) luaU_print(f,listing>1);\n if (dumping)\n {\n  FILE* D= (output==NULL) ? stdout : fopen(output,\"wb\");\n  if (D==NULL) cannot(\"open\");\n  lua_lock(L);\n  luaU_dump(L,f,writer,D,stripping);\n  lua_unlock(L);\n  if (ferror(D)) cannot(\"write\");\n  if (fclose(D)) cannot(\"close\");\n }\n return 0;\n}\n\n// int main(int argc, char* argv[])\n// {\n//  lua_State* L;\n//  int i=doargs(argc,argv);\n//  argc-=i; argv+=i;\n//  if (argc<=0) usage(\"no input files given\");\n//  L=luaL_newstate();\n//  if (L==NULL) fatal(\"cannot create state: not enough memory\");\n//  lua_pushcfunction(L,&pmain);\n//  lua_pushinteger(L,argc);\n//  lua_pushlightuserdata(L,argv);\n//  if (lua_pcall(L,2,0,0)!=LUA_OK) fatal(lua_tostring(L,-1));\n//  lua_close(L);\n//  return EXIT_SUCCESS;\n// }\n\n/*\n** print bytecodes\n*/\n\n#define UPVALNAME(x) ((f->upvalues[x].name) ? getstr(f->upvalues[x].name) : \"-\")\n#define VOID(p) ((const void*)(p))\n#define eventname(i) (getstr(tmname[i]))\n\nstatic void PrintString(const TString* ts)\n{\n const char* s=getstr(ts);\n size_t i,n=tsslen(ts);\n printf(\"\\\"\");\n for (i=0; i<n; i++)\n {\n  int c=(int)(unsigned char)s[i];\n  switch (c)\n  {\n   case '\"':\n\tprintf(\"\\\\\\\"\");\n\tbreak;\n   case '\\\\':\n\tprintf(\"\\\\\\\\\");\n\tbreak;\n   case '\\a':\n\tprintf(\"\\\\a\");\n\tbreak;\n   case '\\b':\n\tprintf(\"\\\\b\");\n\tbreak;\n   case '\\f':\n\tprintf(\"\\\\f\");\n\tbreak;\n   case '\\n':\n\tprintf(\"\\\\n\");\n\tbreak;\n   case '\\r':\n\tprintf(\"\\\\r\");\n\tbreak;\n   case '\\t':\n\tprintf(\"\\\\t\");\n\tbreak;\n   case '\\v':\n\tprintf(\"\\\\v\");\n\tbreak;\n   default:\n\tif (isprint(c)) printf(\"%c\",c); else printf(\"\\\\%03d\",c);\n\tbreak;\n  }\n }\n printf(\"\\\"\");\n}\n\nstatic void PrintType(const Proto* f, int i)\n{\n const TValue* o=&f->k[i];\n switch (ttypetag(o))\n {\n  case LUA_VNIL:\n\tprintf(\"N\");\n\tbreak;\n  case LUA_VFALSE:\n  case LUA_VTRUE:\n\tprintf(\"B\");\n\tbreak;\n  case LUA_VNUMFLT:\n\tprintf(\"F\");\n\tbreak;\n  case LUA_VNUMINT:\n\tprintf(\"I\");\n\tbreak;\n  case LUA_VSHRSTR:\n  case LUA_VLNGSTR:\n\tprintf(\"S\");\n\tbreak;\n  default:\t\t\t\t/* cannot happen */\n\tprintf(\"?%d\",ttypetag(o));\n\tbreak;\n }\n printf(\"\\t\");\n}\n\nstatic void PrintConstant(const Proto* f, int i)\n{\n const TValue* o=&f->k[i];\n switch (ttypetag(o))\n {\n  case LUA_VNIL:\n\tprintf(\"nil\");\n\tbreak;\n  case LUA_VFALSE:\n\tprintf(\"false\");\n\tbreak;\n  case LUA_VTRUE:\n\tprintf(\"true\");\n\tbreak;\n  case LUA_VNUMFLT:\n\t{\n\tchar buff[100];\n\tsprintf(buff,LUA_NUMBER_FMT,fltvalue(o));\n\tprintf(\"%s\",buff);\n\tif (buff[strspn(buff,\"-0123456789\")]=='\\0') printf(\".0\");\n\tbreak;\n\t}\n  case LUA_VNUMINT:\n\tprintf(LUA_INTEGER_FMT,ivalue(o));\n\tbreak;\n  case LUA_VSHRSTR:\n  case LUA_VLNGSTR:\n\tPrintString(tsvalue(o));\n\tbreak;\n  default:\t\t\t\t/* cannot happen */\n\tprintf(\"?%d\",ttypetag(o));\n\tbreak;\n }\n}\n\n#define COMMENT\t\t\"\\t; \"\n#define EXTRAARG\tGETARG_Ax(code[pc+1])\n#define EXTRAARGC\t(EXTRAARG*(MAXARG_C+1))\n#define ISK\t\t(isk ? \"k\" : \"\")\n\nstatic void PrintCode(const Proto* f)\n{\n const Instruction* code=f->code;\n int pc,n=f->sizecode;\n for (pc=0; pc<n; pc++)\n {\n  Instruction i=code[pc];\n  OpCode o=GET_OPCODE(i);\n  int a=GETARG_A(i);\n  int b=GETARG_B(i);\n  int c=GETARG_C(i);\n  int ax=GETARG_Ax(i);\n  int bx=GETARG_Bx(i);\n  int sb=GETARG_sB(i);\n  int sc=GETARG_sC(i);\n  int sbx=GETARG_sBx(i);\n  int isk=GETARG_k(i);\n  int line=luaG_getfuncline(f,pc);\n  printf(\"\\t%d\\t\",pc+1);\n  if (line>0) printf(\"[%d]\\t\",line); else printf(\"[-]\\t\");\n  printf(\"%-9s\\t\",opnames[o]);\n  switch (o)\n  {\n   case OP_MOVE:\n\tprintf(\"%d %d\",a,b);\n\tbreak;\n   case OP_LOADI:\n\tprintf(\"%d %d\",a,sbx);\n\tbreak;\n   case OP_LOADF:\n\tprintf(\"%d %d\",a,sbx);\n\tbreak;\n   case OP_LOADK:\n\tprintf(\"%d %d\",a,bx);\n\tprintf(COMMENT); PrintConstant(f,bx);\n\tbreak;\n   case OP_LOADKX:\n\tprintf(\"%d\",a);\n\tprintf(COMMENT); PrintConstant(f,EXTRAARG);\n\tbreak;\n   case OP_LOADFALSE:\n\tprintf(\"%d\",a);\n\tbreak;\n   case OP_LFALSESKIP:\n\tprintf(\"%d\",a);\n\tbreak;\n   case OP_LOADTRUE:\n\tprintf(\"%d\",a);\n\tbreak;\n   case OP_LOADNIL:\n\tprintf(\"%d %d\",a,b);\n\tprintf(COMMENT \"%d out\",b+1);\n\tbreak;\n   case OP_GETUPVAL:\n\tprintf(\"%d %d\",a,b);\n\tprintf(COMMENT \"%s\",UPVALNAME(b));\n\tbreak;\n   case OP_SETUPVAL:\n\tprintf(\"%d %d\",a,b);\n\tprintf(COMMENT \"%s\",UPVALNAME(b));\n\tbreak;\n   case OP_GETTABUP:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT \"%s\",UPVALNAME(b));\n\tprintf(\" \"); PrintConstant(f,c);\n\tbreak;\n   case OP_GETTABLE:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_GETI:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_GETFIELD:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_SETTABUP:\n\tprintf(\"%d %d %d%s\",a,b,c,ISK);\n\tprintf(COMMENT \"%s\",UPVALNAME(a));\n\tprintf(\" \"); PrintConstant(f,b);\n\tif (isk) { printf(\" \"); PrintConstant(f,c); }\n\tbreak;\n   case OP_SETTABLE:\n\tprintf(\"%d %d %d%s\",a,b,c,ISK);\n\tif (isk) { printf(COMMENT); PrintConstant(f,c); }\n\tbreak;\n   case OP_SETI:\n\tprintf(\"%d %d %d%s\",a,b,c,ISK);\n\tif (isk) { printf(COMMENT); PrintConstant(f,c); }\n\tbreak;\n   case OP_SETFIELD:\n\tprintf(\"%d %d %d%s\",a,b,c,ISK);\n\tprintf(COMMENT); PrintConstant(f,b);\n\tif (isk) { printf(\" \"); PrintConstant(f,c); }\n\tbreak;\n   case OP_NEWTABLE:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT \"%d\",c+EXTRAARGC);\n\tbreak;\n   case OP_SELF:\n\tprintf(\"%d %d %d%s\",a,b,c,ISK);\n\tif (isk) { printf(COMMENT); PrintConstant(f,c); }\n\tbreak;\n   case OP_ADDI:\n\tprintf(\"%d %d %d\",a,b,sc);\n\tbreak;\n   case OP_ADDK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_SUBK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_MULK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_MODK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_POWK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_DIVK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_IDIVK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_BANDK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_BORK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_BXORK:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT); PrintConstant(f,c);\n\tbreak;\n   case OP_SHRI:\n\tprintf(\"%d %d %d\",a,b,sc);\n\tbreak;\n   case OP_SHLI:\n\tprintf(\"%d %d %d\",a,b,sc);\n\tbreak;\n   case OP_ADD:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_SUB:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_MUL:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_MOD:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_POW:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_DIV:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_IDIV:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_BAND:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_BOR:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_BXOR:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_SHL:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_SHR:\n\tprintf(\"%d %d %d\",a,b,c);\n\tbreak;\n   case OP_MMBIN:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT \"%s\",eventname(c));\n\tbreak;\n   case OP_MMBINI:\n\tprintf(\"%d %d %d %d\",a,sb,c,isk);\n\tprintf(COMMENT \"%s\",eventname(c));\n\tif (isk) printf(\" flip\");\n\tbreak;\n   case OP_MMBINK:\n\tprintf(\"%d %d %d %d\",a,b,c,isk);\n\tprintf(COMMENT \"%s \",eventname(c)); PrintConstant(f,b);\n\tif (isk) printf(\" flip\");\n\tbreak;\n   case OP_UNM:\n\tprintf(\"%d %d\",a,b);\n\tbreak;\n   case OP_BNOT:\n\tprintf(\"%d %d\",a,b);\n\tbreak;\n   case OP_NOT:\n\tprintf(\"%d %d\",a,b);\n\tbreak;\n   case OP_LEN:\n\tprintf(\"%d %d\",a,b);\n\tbreak;\n   case OP_CONCAT:\n\tprintf(\"%d %d\",a,b);\n\tbreak;\n   case OP_CLOSE:\n\tprintf(\"%d\",a);\n\tbreak;\n   case OP_TBC:\n\tprintf(\"%d\",a);\n\tbreak;\n   case OP_JMP:\n\tprintf(\"%d\",GETARG_sJ(i));\n\tprintf(COMMENT \"to %d\",GETARG_sJ(i)+pc+2);\n\tbreak;\n   case OP_EQ:\n\tprintf(\"%d %d %d\",a,b,isk);\n\tbreak;\n   case OP_LT:\n\tprintf(\"%d %d %d\",a,b,isk);\n\tbreak;\n   case OP_LE:\n\tprintf(\"%d %d %d\",a,b,isk);\n\tbreak;\n   case OP_EQK:\n\tprintf(\"%d %d %d\",a,b,isk);\n\tprintf(COMMENT); PrintConstant(f,b);\n\tbreak;\n   case OP_EQI:\n\tprintf(\"%d %d %d\",a,sb,isk);\n\tbreak;\n   case OP_LTI:\n\tprintf(\"%d %d %d\",a,sb,isk);\n\tbreak;\n   case OP_LEI:\n\tprintf(\"%d %d %d\",a,sb,isk);\n\tbreak;\n   case OP_GTI:\n\tprintf(\"%d %d %d\",a,sb,isk);\n\tbreak;\n   case OP_GEI:\n\tprintf(\"%d %d %d\",a,sb,isk);\n\tbreak;\n   case OP_TEST:\n\tprintf(\"%d %d\",a,isk);\n\tbreak;\n   case OP_TESTSET:\n\tprintf(\"%d %d %d\",a,b,isk);\n\tbreak;\n   case OP_CALL:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT);\n\tif (b==0) printf(\"all in \"); else printf(\"%d in \",b-1);\n\tif (c==0) printf(\"all out\"); else printf(\"%d out\",c-1);\n\tbreak;\n   case OP_TAILCALL:\n\tprintf(\"%d %d %d%s\",a,b,c,ISK);\n\tprintf(COMMENT \"%d in\",b-1);\n\tbreak;\n   case OP_RETURN:\n\tprintf(\"%d %d %d%s\",a,b,c,ISK);\n\tprintf(COMMENT);\n\tif (b==0) printf(\"all out\"); else printf(\"%d out\",b-1);\n\tbreak;\n   case OP_RETURN0:\n\tbreak;\n   case OP_RETURN1:\n\tprintf(\"%d\",a);\n\tbreak;\n   case OP_FORLOOP:\n\tprintf(\"%d %d\",a,bx);\n\tprintf(COMMENT \"to %d\",pc-bx+2);\n\tbreak;\n   case OP_FORPREP:\n\tprintf(\"%d %d\",a,bx);\n\tprintf(COMMENT \"exit to %d\",pc+bx+3);\n\tbreak;\n   case OP_TFORPREP:\n\tprintf(\"%d %d\",a,bx);\n\tprintf(COMMENT \"to %d\",pc+bx+2);\n\tbreak;\n   case OP_TFORCALL:\n\tprintf(\"%d %d\",a,c);\n\tbreak;\n   case OP_TFORLOOP:\n\tprintf(\"%d %d\",a,bx);\n\tprintf(COMMENT \"to %d\",pc-bx+2);\n\tbreak;\n   case OP_SETLIST:\n\tprintf(\"%d %d %d\",a,b,c);\n\tif (isk) printf(COMMENT \"%d\",c+EXTRAARGC);\n\tbreak;\n   case OP_CLOSURE:\n\tprintf(\"%d %d\",a,bx);\n\tprintf(COMMENT \"%p\",VOID(f->p[bx]));\n\tbreak;\n   case OP_VARARG:\n\tprintf(\"%d %d\",a,c);\n\tprintf(COMMENT);\n\tif (c==0) printf(\"all out\"); else printf(\"%d out\",c-1);\n\tbreak;\n   case OP_VARARGPREP:\n\tprintf(\"%d\",a);\n\tbreak;\n   case OP_EXTRAARG:\n\tprintf(\"%d\",ax);\n\tbreak;\n#if 0\n   default:\n\tprintf(\"%d %d %d\",a,b,c);\n\tprintf(COMMENT \"not handled\");\n\tbreak;\n#endif\n  }\n  printf(\"\\n\");\n }\n}\n\n\n#define SS(x)\t((x==1)?\"\":\"s\")\n#define S(x)\t(int)(x),SS(x)\n\nstatic void PrintHeader(const Proto* f)\n{\n const char* s=f->source ? getstr(f->source) : \"=?\";\n if (*s=='@' || *s=='=')\n  s++;\n else if (*s==LUA_SIGNATURE[0])\n  s=\"(bstring)\";\n else\n  s=\"(string)\";\n printf(\"\\n%s <%s:%d,%d> (%d instruction%s at %p)\\n\",\n\t(f->linedefined==0)?\"main\":\"function\",s,\n\tf->linedefined,f->lastlinedefined,\n\tS(f->sizecode),VOID(f));\n printf(\"%d%s param%s, %d slot%s, %d upvalue%s, \",\n\t(int)(f->numparams),f->is_vararg?\"+\":\"\",SS(f->numparams),\n\tS(f->maxstacksize),S(f->sizeupvalues));\n printf(\"%d local%s, %d constant%s, %d function%s\\n\",\n\tS(f->sizelocvars),S(f->sizek),S(f->sizep));\n}\n\nstatic void PrintDebug(const Proto* f)\n{\n int i,n;\n n=f->sizek;\n printf(\"constants (%d) for %p:\\n\",n,VOID(f));\n for (i=0; i<n; i++)\n {\n  printf(\"\\t%d\\t\",i);\n  PrintType(f,i);\n  PrintConstant(f,i);\n  printf(\"\\n\");\n }\n n=f->sizelocvars;\n printf(\"locals (%d) for %p:\\n\",n,VOID(f));\n for (i=0; i<n; i++)\n {\n  printf(\"\\t%d\\t%s\\t%d\\t%d\\n\",\n  i,getstr(f->locvars[i].varname),f->locvars[i].startpc+1,f->locvars[i].endpc+1);\n }\n n=f->sizeupvalues;\n printf(\"upvalues (%d) for %p:\\n\",n,VOID(f));\n for (i=0; i<n; i++)\n {\n  printf(\"\\t%d\\t%s\\t%d\\t%d\\n\",\n  i,UPVALNAME(i),f->upvalues[i].instack,f->upvalues[i].idx);\n }\n}\n\nstatic void PrintFunction(const Proto* f, int full)\n{\n int i,n=f->sizep;\n PrintHeader(f);\n PrintCode(f);\n if (full) PrintDebug(f);\n for (i=0; i<n; i++) PrintFunction(f->p[i],full);\n}\n"
        }
    ]
}