{
    "sourceFile": "lualib/include/lauxlib.h",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1653551379960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1653551379960,
            "name": "Commit-0",
            "content": "/*\n** $Id: lauxlib.h $\n** Auxiliary functions for building Lua libraries\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lauxlib_h\n#define lauxlib_h\n\n\n#include <stddef.h>\n#include <stdio.h>\n\n#include \"luaconf.h\"\n#include \"lua.h\"\n\n\n/* global table */\n#define LUA_GNAME\t\"_G\"\n\n\ntypedef struct luaL_Buffer luaL_Buffer;\n\n\n/* extra error code for 'luaL_loadfilex' */\n#define LUA_ERRFILE     (LUA_ERRERR+1)\n\n\n/* key, in the registry, for table of loaded modules */\n#define LUA_LOADED_TABLE\t\"_LOADED\"\n\n\n/* key, in the registry, for table of preloaded loaders */\n#define LUA_PRELOAD_TABLE\t\"_PRELOAD\"\n\n\ntypedef struct luaL_Reg {\n  const char *name;\n  lua_CFunction func;\n} luaL_Reg;\n\n\n#define LUAL_NUMSIZES\t(sizeof(lua_Integer)*16 + sizeof(lua_Number))\n\nLUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver, size_t sz);\n#define luaL_checkversion(L)  \\\n\t  luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES)\n\nLUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);\nLUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);\nLUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);\nLUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg);\nLUALIB_API int (luaL_typeerror) (lua_State *L, int arg, const char *tname);\nLUALIB_API const char *(luaL_checklstring) (lua_State *L, int arg,\n                                                          size_t *l);\nLUALIB_API const char *(luaL_optlstring) (lua_State *L, int arg,\n                                          const char *def, size_t *l);\nLUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int arg);\nLUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int arg, lua_Number def);\n\nLUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int arg);\nLUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int arg,\n                                          lua_Integer def);\n\nLUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);\nLUALIB_API void (luaL_checktype) (lua_State *L, int arg, int t);\nLUALIB_API void (luaL_checkany) (lua_State *L, int arg);\n\nLUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);\nLUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);\nLUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);\nLUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);\n\nLUALIB_API void (luaL_where) (lua_State *L, int lvl);\nLUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);\n\nLUALIB_API int (luaL_checkoption) (lua_State *L, int arg, const char *def,\n                                   const char *const lst[]);\n\nLUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);\nLUALIB_API int (luaL_execresult) (lua_State *L, int stat);\n\n\n/* predefined references */\n#define LUA_NOREF       (-2)\n#define LUA_REFNIL      (-1)\n\nLUALIB_API int (luaL_ref) (lua_State *L, int t);\nLUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);\n\nLUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,\n                                               const char *mode);\n\n#define luaL_loadfile(L,f)\tluaL_loadfilex(L,f,NULL)\n\nLUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,\n                                   const char *name, const char *mode);\nLUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);\n\nLUALIB_API lua_State *(luaL_newstate) (void);\n\nLUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);\n\nLUALIB_API void (luaL_addgsub) (luaL_Buffer *b, const char *s,\n                                     const char *p, const char *r);\nLUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s,\n                                    const char *p, const char *r);\n\nLUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);\n\nLUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);\n\nLUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,\n                                  const char *msg, int level);\n\nLUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,\n                                 lua_CFunction openf, int glb);\n\n/*\n** ===============================================================\n** some useful macros\n** ===============================================================\n*/\n\n\n#define luaL_newlibtable(L,l)\t\\\n  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)\n\n#define luaL_newlib(L,l)  \\\n  (luaL_checkversion(L), luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))\n\n#define luaL_argcheck(L, cond,arg,extramsg)\t\\\n\t((void)(luai_likely(cond) || luaL_argerror(L, (arg), (extramsg))))\n\n#define luaL_argexpected(L,cond,arg,tname)\t\\\n\t((void)(luai_likely(cond) || luaL_typeerror(L, (arg), (tname))))\n\n#define luaL_checkstring(L,n)\t(luaL_checklstring(L, (n), NULL))\n#define luaL_optstring(L,n,d)\t(luaL_optlstring(L, (n), (d), NULL))\n\n#define luaL_typename(L,i)\tlua_typename(L, lua_type(L,(i)))\n\n#define luaL_dofile(L, fn) \\\n\t(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n#define luaL_dostring(L, s) \\\n\t(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n#define luaL_getmetatable(L,n)\t(lua_getfield(L, LUA_REGISTRYINDEX, (n)))\n\n#define luaL_opt(L,f,n,d)\t(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))\n\n#define luaL_loadbuffer(L,s,sz,n)\tluaL_loadbufferx(L,s,sz,n,NULL)\n\n\n/*\n** Perform arithmetic operations on lua_Integer values with wrap-around\n** semantics, as the Lua core does.\n*/\n#define luaL_intop(op,v1,v2)  \\\n\t((lua_Integer)((lua_Unsigned)(v1) op (lua_Unsigned)(v2)))\n\n\n/* push the value used to represent failure/error */\n#define luaL_pushfail(L)\tlua_pushnil(L)\n\n\n/*\n** Internal assertions for in-house debugging\n*/\n#if !defined(lua_assert)\n\n#if defined LUAI_ASSERT\n  #include <assert.h>\n  #define lua_assert(c)\t\tassert(c)\n#else\n  #define lua_assert(c)\t\t((void)0)\n#endif\n\n#endif\n\n\n\n/*\n** {======================================================\n** Generic Buffer manipulation\n** =======================================================\n*/\n\nstruct luaL_Buffer {\n  char *b;  /* buffer address */\n  size_t size;  /* buffer size */\n  size_t n;  /* number of characters in buffer */\n  lua_State *L;\n  union {\n    LUAI_MAXALIGN;  /* ensure maximum alignment for buffer */\n    char b[LUAL_BUFFERSIZE];  /* initial buffer */\n  } init;\n};\n\n\n#define luaL_bufflen(bf)\t((bf)->n)\n#define luaL_buffaddr(bf)\t((bf)->b)\n\n\n#define luaL_addchar(B,c) \\\n  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \\\n   ((B)->b[(B)->n++] = (c)))\n\n#define luaL_addsize(B,s)\t((B)->n += (s))\n\n#define luaL_buffsub(B,s)\t((B)->n -= (s))\n\nLUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);\nLUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);\nLUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);\nLUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);\nLUALIB_API void (luaL_addvalue) (luaL_Buffer *B);\nLUALIB_API void (luaL_pushresult) (luaL_Buffer *B);\nLUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);\nLUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);\n\n#define luaL_prepbuffer(B)\tluaL_prepbuffsize(B, LUAL_BUFFERSIZE)\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** File handles for IO library\n** =======================================================\n*/\n\n/*\n** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and\n** initial structure 'luaL_Stream' (it may contain other fields\n** after that initial structure).\n*/\n\n#define LUA_FILEHANDLE          \"FILE*\"\n\n\ntypedef struct luaL_Stream {\n  FILE *f;  /* stream (NULL for incompletely created streams) */\n  lua_CFunction closef;  /* to close stream (NULL for closed streams) */\n} luaL_Stream;\n\n/* }====================================================== */\n\n/*\n** {==================================================================\n** \"Abstraction Layer\" for basic report of messages and errors\n** ===================================================================\n*/\n\n/* print a string */\n#if !defined(lua_writestring)\n#define lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)\n#endif\n\n/* print a newline and flush the output */\n#if !defined(lua_writeline)\n#define lua_writeline()        (lua_writestring(\"\\n\", 1), fflush(stdout))\n#endif\n\n/* print an error message */\n#if !defined(lua_writestringerror)\n#define lua_writestringerror(s,p) \\\n        (fprintf(stderr, (s), (p)), fflush(stderr))\n#endif\n\n/* }================================================================== */\n\n\n/*\n** {============================================================\n** Compatibility with deprecated conversions\n** =============================================================\n*/\n#if defined(LUA_COMPAT_APIINTCASTS)\n\n#define luaL_checkunsigned(L,a)\t((lua_Unsigned)luaL_checkinteger(L,a))\n#define luaL_optunsigned(L,a,d)\t\\\n\t((lua_Unsigned)luaL_optinteger(L,a,(lua_Integer)(d)))\n\n#define luaL_checkint(L,n)\t((int)luaL_checkinteger(L, (n)))\n#define luaL_optint(L,n,d)\t((int)luaL_optinteger(L, (n), (d)))\n\n#define luaL_checklong(L,n)\t((long)luaL_checkinteger(L, (n)))\n#define luaL_optlong(L,n,d)\t((long)luaL_optinteger(L, (n), (d)))\n\n#endif\n/* }============================================================ */\n\n\n\n#endif\n\n\n"
        }
    ]
}